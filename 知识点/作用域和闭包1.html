<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <title>闭包</title>
    <style>
        * {
            font-size: 16px;
        }

    </style>

</head>
<body>

<pre>


</pre>


<script>
  /*
  闭包 进一步的理解


  * */

  // 形成闭包, 自制行函数形成闭包，实质就是形成一个作用域，这个作用域和普通函数形成的作用域的区别是函数运行完不会自动释放
  let fn = (function () {
    let count = 0

    return function () {
      count++;
      console.log(count)
    }

  })();

  fn();
  fn();
  fn();
  fn();


  console.log('------------')

  // 全局作用域中，对变量的操作，是累加的

  let count = 0
  let fn1 = function () {
    return function () {
      count++;
      console.log(count)
    }

  }
  fn1()();
  fn1()();
  fn1()();


  console.log('------------')
  // es5中，只有函数作用域和全局作用域
  // 这里的i相当于全局作用域
  for (var i = 0; i < 10; i++) {
    console.log(i);
  }
  console.log('输出i的值－－', i);

  console.log('------------')

  function f() {
    var arr = [];
    for (var i = 0; i < 10; i++) {
      arr[i] = function () {
        console.log('---',i)
      }
    }
    for (var j=0; j<10;j++){
      arr[j]();
    }
  }
  f();

  console.log('------------')
  function f1() { // 这是一个函数作用域
    var arr = [];
    for (var i = 0; i < 10; i++) {
      (function (i) { // 这是一个匿名函数作用域
        arr[i] = function () {
          console.log('---',i)
        }
      })(i);
    }

    console.log(arr);

    for (var j=0; j<10;j++){
      arr[j]();
    }
  }
  f1();


  console.log('------------')
  function f2() {
    var arr = [];
    for (let i = 0; i < 10; i++) {
      arr[i] = function () {
        console.log('---',i)
      }
    }
    for (var j=0; j<10;j++){
      arr[j]();
    }
  }
  f2();
</script>
</body>
</html>
